/**\n * ResultDisplayManager - Central coordinator for all result displays\n * Prevents race conditions, collisions, and ensures clean separation of concerns\n */\nclass ResultDisplayManager {\n    constructor() {\n        this.handlers = new Map();\n        this.isDisplaying = false;\n        this.displayQueue = [];\n        this.defaultHandler = null;\n        \n        console.log('üéØ ResultDisplayManager initialized');\n    }\n\n    /**\n     * Register a component's result display handler\n     * @param {string} componentName - Unique name for the component\n     * @param {Array<string>} toolPatterns - Tool name patterns this component handles\n     * @param {Function} displayHandler - Function to handle result display\n     * @param {number} priority - Priority level (higher = more priority)\n     */\n    registerHandler(componentName, toolPatterns, displayHandler, priority = 0) {\n        const handlerInfo = {\n            componentName,\n            toolPatterns,\n            displayHandler,\n            priority,\n            registeredAt: new Date().toISOString()\n        };\n        \n        this.handlers.set(componentName, handlerInfo);\n        \n        console.log(`üìù Registered result handler for ${componentName}:`, {\n            toolPatterns,\n            priority\n        });\n    }\n\n    /**\n     * Set the default fallback handler\n     * @param {Function} defaultHandler - Default result display function\n     */\n    setDefaultHandler(defaultHandler) {\n        this.defaultHandler = defaultHandler;\n        console.log('üîß Default result handler set');\n    }\n\n    /**\n     * Display a result using the appropriate handler\n     * @param {Object} result - The result object to display\n     * @param {Object} context - Additional context (toolName, parameters, etc.)\n     */\n    async displayResult(result, context = {}) {\n        // Prevent race conditions with mutex pattern\n        if (this.isDisplaying) {\n            console.log('‚è≥ Result display in progress, queuing...', context.toolName);\n            this.displayQueue.push({ result, context });\n            return;\n        }\n\n        this.isDisplaying = true;\n        \n        try {\n            await this._processResult(result, context);\n            \n            // Process queue if there are pending displays\n            if (this.displayQueue.length > 0) {\n                const next = this.displayQueue.shift();\n                setTimeout(() => {\n                    this.isDisplaying = false;\n                    this.displayResult(next.result, next.context);\n                }, 50); // Small delay to prevent stack overflow\n                return;\n            }\n            \n        } catch (error) {\n            console.error('‚ùå Error in result display:', error);\n            this._fallbackDisplay(result, context, error);\n        } finally {\n            this.isDisplaying = false;\n        }\n    }\n\n    /**\n     * Internal method to process a single result\n     * @private\n     */\n    async _processResult(result, context) {\n        console.log('üîç Processing result display:', {\n            toolName: context.toolName,\n            success: result.success,\n            hasResult: !!result.result\n        });\n\n        // Find the best handler for this result\n        const handler = this._findBestHandler(context.toolName, result);\n        \n        if (handler) {\n            console.log(`‚úÖ Using ${handler.componentName} handler for ${context.toolName}`);\n            \n            try {\n                // Call the component's display handler\n                await handler.displayHandler(result, context);\n                \n                // Log successful display\n                this._logDisplaySuccess(handler.componentName, context.toolName);\n                \n            } catch (componentError) {\n                console.error(`‚ùå Component ${handler.componentName} display failed:`, componentError);\n                \n                // Fallback to default handler\n                this._fallbackDisplay(result, context, componentError);\n            }\n        } else {\n            console.log('üìã No specific handler found, using default display');\n            this._fallbackDisplay(result, context);\n        }\n    }\n\n    /**\n     * Find the best handler for a given tool name and result\n     * @private\n     */\n    _findBestHandler(toolName, result) {\n        if (!toolName) return null;\n\n        let bestHandler = null;\n        let highestPriority = -1;\n\n        for (const [componentName, handlerInfo] of this.handlers) {\n            // Check if any tool pattern matches\n            const matches = handlerInfo.toolPatterns.some(pattern => {\n                if (typeof pattern === 'string') {\n                    return toolName.includes(pattern);\n                } else if (pattern instanceof RegExp) {\n                    return pattern.test(toolName);\n                }\n                return false;\n            });\n\n            if (matches && handlerInfo.priority > highestPriority) {\n                bestHandler = handlerInfo;\n                highestPriority = handlerInfo.priority;\n            }\n        }\n\n        return bestHandler;\n    }\n\n    /**\n     * Fallback display when component handlers fail or don't exist\n     * @private\n     */\n    _fallbackDisplay(result, context, error = null) {\n        console.log('üîÑ Using fallback display:', {\n            toolName: context.toolName,\n            hasDefaultHandler: !!this.defaultHandler,\n            error: error?.message\n        });\n\n        if (this.defaultHandler) {\n            try {\n                this.defaultHandler(result, context);\n            } catch (fallbackError) {\n                console.error('‚ùå Even fallback display failed:', fallbackError);\n                this._emergencyDisplay(result, context);\n            }\n        } else {\n            this._emergencyDisplay(result, context);\n        }\n    }\n\n    /**\n     * Emergency display when everything else fails\n     * @private\n     */\n    _emergencyDisplay(result, context) {\n        console.log('üö® Using emergency display');\n        \n        const container = document.getElementById('execution-results');\n        if (container) {\n            const toolName = context.toolName || 'Unknown Tool';\n            const formattedToolName = toolName\n                .replace('get-', '')\n                .replace('-with-sign', '')\n                .replace(/-/g, ' ')\n                .replace(/\\b\\w/g, l => l.toUpperCase());\n\n            container.innerHTML = `\n                <div class=\"bg-${result.success ? 'green' : 'red'}-50 border border-${result.success ? 'green' : 'red'}-200 rounded-lg p-4\">\n                    <div class=\"flex items-center\">\n                        <div class=\"text-${result.success ? 'green' : 'red'}-600 text-2xl mr-3\">${result.success ? '‚úÖ' : '‚ùå'}</div>\n                        <div>\n                            <h3 class=\"text-lg font-semibold text-${result.success ? 'green' : 'red'}-800\">${result.success ? 'Success' : 'Failed'}</h3>\n                            <p class=\"text-${result.success ? 'green' : 'red'}-700\">${formattedToolName} ${result.success ? 'completed' : 'failed'}</p>\n                        </div>\n                    </div>\n                    ${!result.success && result.error ? `\n                        <div class=\"mt-2 text-sm text-red-600\">\n                            <strong>Error:</strong> ${result.error}\n                        </div>\n                    ` : ''}\n                </div>\n            `;\n        }\n    }\n\n    /**\n     * Log successful display for debugging and monitoring\n     * @private\n     */\n    _logDisplaySuccess(componentName, toolName) {\n        console.log(`üìä Result display completed:`, {\n            component: componentName,\n            toolName: toolName,\n            timestamp: new Date().toISOString()\n        });\n    }\n\n    /**\n     * Get statistics about registered handlers\n     */\n    getStats() {\n        return {\n            totalHandlers: this.handlers.size,\n            handlers: Array.from(this.handlers.entries()).map(([name, info]) => ({\n                componentName: name,\n                toolPatterns: info.toolPatterns,\n                priority: info.priority,\n                registeredAt: info.registeredAt\n            })),\n            isDisplaying: this.isDisplaying,\n            queueLength: this.displayQueue.length\n        };\n    }\n\n    /**\n     * Clear all handlers (useful for testing)\n     */\n    clearHandlers() {\n        this.handlers.clear();\n        this.defaultHandler = null;\n        console.log('üßπ All result handlers cleared');\n    }\n\n    /**\n     * Force clear the display queue (emergency use)\n     */\n    clearQueue() {\n        this.displayQueue = [];\n        this.isDisplaying = false;\n        console.log('üßπ Display queue cleared and mutex released');\n    }\n}\n\n// Create global instance\nwindow.resultDisplayManager = new ResultDisplayManager();\n\n// Export for module usage\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = ResultDisplayManager;\n}\n\nconsole.log('üéØ ResultDisplayManager loaded and ready');"